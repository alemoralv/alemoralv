<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canonical Graph Process</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background-color: #f8fafc; }
        .no-select { user-select: none; -webkit-user-select: none; }
    </style>
</head>
<body>

    <div id="root" style="height: 100vh; width: 100vw;"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ICONS ---
        const IconWrapper = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
        );
        const Play = (props) => <IconWrapper {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></IconWrapper>;
        const Pause = (props) => <IconWrapper {...props}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></IconWrapper>;
        const SkipForward = (props) => <IconWrapper {...props}><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></IconWrapper>;
        const RotateCcw = (props) => <IconWrapper {...props}><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></IconWrapper>;
        const ZoomIn = (props) => <IconWrapper {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconWrapper>;
        const ZoomOut = (props) => <IconWrapper {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconWrapper>;
        const Move = (props) => <IconWrapper {...props}><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 15 22 12 19 9"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></IconWrapper>;
        const BarChart2 = (props) => <IconWrapper {...props}><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></IconWrapper>;

        // --- HISTOGRAM COMPONENT (Extracted for stability) ---
        const Histogram = ({ degreeCounts, maxDegree, minDegree, dimensions, nodesCount, p }) => {
            const data = Array.from(degreeCounts.entries()).sort((a, b) => a[0] - b[0]);
            if (data.length === 0) return null;

            const maxCount = Math.max(...data.map(d => d[1]));
            const width = dimensions.width;
            const height = 150; 
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };
            const chartW = width - padding.left - padding.right;
            const chartH = height - padding.top - padding.bottom;
            const barWidth = Math.max(2, Math.min(30, (chartW / data.length) - 2));
            const minX = data[0][0];
            const maxX = data[data.length - 1][0];
            const rangeX = Math.max(1, maxX - minX);

            // Gaussian Curve Calculation
            const mu = (nodesCount - 1) * p;
            const sigma = Math.sqrt((nodesCount - 1) * p * (1 - p));
            
            let pathD = "";
            if (nodesCount > 10 && sigma > 0) { 
                const curvePoints = [];
                const step = rangeX / 100; 
                const constant = 1 / (sigma * Math.sqrt(2 * Math.PI));
                
                for (let xVal = minX; xVal <= maxX; xVal += step) {
                    const z = (xVal - mu) / sigma;
                    const prob = constant * Math.exp(-0.5 * z * z);
                    const theoreticalCount = prob * nodesCount; 
                    const px = padding.left + ((xVal - minX) / rangeX) * (chartW - barWidth);
                    const ph = (theoreticalCount / maxCount) * chartH; 
                    const py = height - padding.bottom - ph;
                    curvePoints.push([px, py]);
                }
                
                if (curvePoints.length > 0) {
                    pathD = `M ${curvePoints[0][0]} ${curvePoints[0][1]}`;
                    for (let i = 1; i < curvePoints.length; i++) {
                        pathD += ` L ${curvePoints[i][0]} ${curvePoints[i][1]}`;
                    }
                }
            }

            return (
                <div className="w-full h-[150px] bg-white border-t border-slate-200 p-2 relative shrink-0">
                    <h3 className="absolute top-2 left-4 text-[10px] uppercase font-bold text-slate-400 flex items-center gap-1">
                        <BarChart2 size={12}/> Degree Distribution
                    </h3>
                    <svg width="100%" height="100%" viewBox={`0 0 ${width} ${height}`}>
                        <line x1={padding.left} y1={height - padding.bottom} x2={width - padding.right} y2={height - padding.bottom} stroke="#cbd5e1" strokeWidth="1" />
                        <line x1={padding.left} y1={padding.top} x2={padding.left} y2={height - padding.bottom} stroke="#cbd5e1" strokeWidth="1" />

                        {data.map(([degree, count]) => {
                            const x = padding.left + ((degree - minX) / rangeX) * (chartW - barWidth);
                            const barH = (count / maxCount) * chartH;
                            const y = height - padding.bottom - barH;
                            
                            let hue = 270;
                            if (maxDegree !== minDegree) {
                                const ratio = (degree - minDegree) / (maxDegree - minDegree);
                                hue = 270 - (ratio * 270);
                            }
                            return (
                                <g key={degree} className="group">
                                    <rect x={x} y={y} width={barWidth} height={barH} fill={`hsl(${hue}, 75%, 55%)`} className="hover:opacity-80 transition-all" />
                                    <title>{`Degree: ${degree}, Count: ${count}`}</title>
                                </g>
                            );
                        })}
                        {nodesCount > 10 && pathD && <path d={pathD} fill="none" stroke="#10b981" strokeWidth="2" strokeDasharray="4 2" className="pointer-events-none" />}
                        <text x={padding.left} y={height - 10} fontSize="10" fill="#64748b" textAnchor="middle">{minX}</text>
                        <text x={width - padding.right} y={height - 10} fontSize="10" fill="#64748b" textAnchor="middle">{maxX}</text>
                        <text x={padding.left - 5} y={padding.top + 5} fontSize="10" fill="#64748b" textAnchor="end">{maxCount}</text>
                        {nodesCount > 10 && <text x={width - padding.right} y={padding.top + 10} fontSize="10" fill="#10b981" textAnchor="end">--- Normal Approx. (p={p.toFixed(2)})</text>}
                    </svg>
                </div>
            );
        };

        // --- MAIN APP COMPONENT ---
        const CanonicalGraphProcess = () => {
          const [nodes, setNodes] = useState([{ id: 1, x: 0, y: 0, vx: 0, vy: 0 }]);
          const [links, setLinks] = useState([]);
          const [isPlaying, setIsPlaying] = useState(false);
          const [speed, setSpeed] = useState(500); 
          
          const [p, setP] = useState(0.5);
          const pRef = useRef(0.5);

          const [longestPathEdges, setLongestPathEdges] = useState(new Set());
          const [degreeMap, setDegreeMap] = useState(new Map([[1, 0]]));
          const [degreeCounts, setDegreeCounts] = useState(new Map([[0, 1]])); 
          const [maxDegree, setMaxDegree] = useState(0);
          const [minDegree, setMinDegree] = useState(0);
          
          const [transform, setTransform] = useState({ x: 0, y: 0, k: 0.4 });
          const [isPanning, setIsPanning] = useState(false);
          const [lastMouse, setLastMouse] = useState({ x: 0, y: 0 });

          const draggedNodeIdRef = useRef(null); 
          const canvasRef = useRef(null);
          const requestRef = useRef();
          
          const [dimensions, setDimensions] = useState({ width: 800, height: 600 });
          
          const simulationNodes = useRef([{ id: 1, x: 0, y: 0, vx: 0, vy: 0 }]);
          const linksRef = useRef([]);

          useEffect(() => {
            if (!canvasRef.current) return;
            const updateSize = () => {
                if (canvasRef.current) {
                    const { clientWidth, clientHeight } = canvasRef.current;
                    if (clientWidth > 0 && clientHeight > 0) {
                        setDimensions({ width: clientWidth, height: clientHeight });
                    }
                }
            };
            updateSize();
            const observer = new ResizeObserver(updateSize);
            observer.observe(canvasRef.current);
            return () => observer.disconnect();
          }, []);

          const updateGraphAnalysis = (currentNodes, currentLinks) => {
            if (!currentNodes || currentNodes.length === 0) return;

            const degrees = new Map();
            const counts = new Map(); 
            
            currentNodes.forEach(n => degrees.set(n.id, 0));
            currentLinks.forEach(l => {
                degrees.set(l.source, (degrees.get(l.source) || 0) + 1);
                degrees.set(l.target, (degrees.get(l.target) || 0) + 1);
            });
            setDegreeMap(degrees);

            let max = 0;
            let min = Infinity;
            
            for (let d of degrees.values()) {
                if (d > max) max = d;
                if (d < min) min = d;
                counts.set(d, (counts.get(d) || 0) + 1);
            }
            
            if (min === Infinity) min = 0;
            setMaxDegree(max);
            setMinDegree(min);
            setDegreeCounts(counts);

            if (currentNodes.length < 2) {
                setLongestPathEdges(new Set());
                return;
            }

            const adj = new Map();
            currentNodes.forEach(n => adj.set(n.id, []));
            currentLinks.forEach(l => {
                if (adj.has(l.source) && adj.has(l.target)) {
                    adj.get(l.source).push(l.target);
                    adj.get(l.target).push(l.source);
                }
            });

            // Check connectivity first (simple BFS)
            const visited = new Set();
            const q = [currentNodes[0].id];
            visited.add(currentNodes[0].id);
            let head = 0;
            while(head < q.length) {
                const u = q[head++];
                const neighbors = adj.get(u) || [];
                for(let v of neighbors) {
                    if(!visited.has(v)) {
                        visited.add(v);
                        q.push(v);
                    }
                }
            }
            if (visited.size !== currentNodes.length) {
                setLongestPathEdges(new Set());
                return; // Disconnected graph
            }

            let globalMaxDist = -1;
            let globalBestPath = new Set();
            
            // For smaller graphs, we can BFS from all nodes to find exact diameter
            // For performance on large graphs, you might want to limit this, but here we do all.
            const startNodes = currentNodes; 

            for (const startNode of startNodes) {
                const dist = new Map();
                const pred = new Map();
                const queue = [startNode.id];
                dist.set(startNode.id, 0);
                
                let localMaxDist = 0;
                let localFarthestNode = startNode.id;

                let bfsHead = 0;
                while(bfsHead < queue.length) {
                    const u = queue[bfsHead++];
                    const d = dist.get(u);
                    
                    if (d > localMaxDist) {
                        localMaxDist = d;
                        localFarthestNode = u;
                    }

                    const neighbors = adj.get(u) || [];
                    for (const v of neighbors) {
                        if (!dist.has(v)) {
                            dist.set(v, d + 1);
                            pred.set(v, u);
                            queue.push(v);
                        }
                    }
                }

                if (localMaxDist > globalMaxDist) {
                    globalMaxDist = localMaxDist;
                    const pathEdges = new Set();
                    let curr = localFarthestNode;
                    while (curr !== startNode.id) {
                        const prev = pred.get(curr);
                        if (prev === undefined) break; 
                        const edgeKey = `${Math.min(curr, prev)}-${Math.max(curr, prev)}`;
                        pathEdges.add(edgeKey);
                        curr = prev;
                    }
                    globalBestPath = pathEdges;
                }
            }
            setLongestPathEdges(globalBestPath);
          };

          const addNode = useCallback(() => {
            const currentSimNodes = simulationNodes.current;
            const newNodeId = currentSimNodes.length + 1;
            
            const spawnRadius = Math.max(100, Math.sqrt(currentSimNodes.length) * 40);
            const angle = Math.random() * 2 * Math.PI;
            
            const newNode = {
              id: newNodeId,
              x: Math.cos(angle) * spawnRadius,
              y: Math.sin(angle) * spawnRadius,
              vx: 0,
              vy: 0,
            };

            const newLinks = [];
            const currentP = pRef.current; 

            currentSimNodes.forEach(targetNode => {
              if (Math.random() < currentP) {
                newLinks.push({ source: newNodeId, target: targetNode.id });
              }
            });

            simulationNodes.current.push(newNode);
            const nextLinks = [...linksRef.current, ...newLinks];
            linksRef.current = nextLinks;

            setNodes(prev => [...prev, { ...newNode }]);
            setLinks(nextLinks);

            updateGraphAnalysis(simulationNodes.current, nextLinks);
          }, []);

          const handlePChange = (e) => {
              const val = parseFloat(e.target.value);
              setP(val);
              pRef.current = val;
          };

          const reset = () => {
            const initialNode = { id: 1, x: 0, y: 0, vx: 0, vy: 0 };
            simulationNodes.current = [initialNode];
            setNodes([initialNode]);
            setLinks([]);
            linksRef.current = [];
            setDegreeMap(new Map([[1,0]]));
            setDegreeCounts(new Map([[0,1]]));
            setMaxDegree(0);
            setMinDegree(0);
            setLongestPathEdges(new Set());
            setIsPlaying(false);
            setTransform({ x: 0, y: 0, k: 0.4 }); 
          };

          useEffect(() => {
            let interval;
            if (isPlaying) {
              interval = setInterval(addNode, speed);
            }
            return () => clearInterval(interval);
          }, [isPlaying, addNode, speed]);


          const handleWheel = (e) => {
            e.preventDefault();
            const scaleFactor = 1.1;
            const direction = e.deltaY > 0 ? -1 : 1;
            let newScale = transform.k * (direction > 0 ? scaleFactor : 1 / scaleFactor);
            newScale = Math.min(Math.max(0.1, newScale), 5);
            setTransform(prev => ({ ...prev, k: newScale }));
          };

          const handleCanvasMouseDown = (e) => {
            setIsPanning(true);
            setLastMouse({ x: e.clientX, y: e.clientY });
          };

          const handleNodeMouseDown = (e, nodeId) => {
            e.stopPropagation();
            draggedNodeIdRef.current = nodeId;
            setLastMouse({ x: e.clientX, y: e.clientY });
          };

          const handleMouseMove = (e) => {
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            setLastMouse({ x: e.clientX, y: e.clientY });

            if (draggedNodeIdRef.current !== null) {
                const simNode = simulationNodes.current.find(n => n.id === draggedNodeIdRef.current);
                if (simNode) {
                    simNode.x += dx / transform.k;
                    simNode.y += dy / transform.k;
                    simNode.vx = 0;
                    simNode.vy = 0;
                }
                return;
            }
            if (isPanning) {
                setTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
            }
          };

          const handleMouseUp = () => {
            setIsPanning(false);
            draggedNodeIdRef.current = null;
          };

          useEffect(() => {
            const tick = () => {
              const simNodes = simulationNodes.current;
              const currentLinks = linksRef.current;
              
              const k_repulse = 8000; 
              const k_spring = 0.015; 
              const spring_len = 200; 
              const center_force = 0.003; 
              const max_velocity = 8.0;

              const fx = new Float32Array(simNodes.length).fill(0);
              const fy = new Float32Array(simNodes.length).fill(0);

              // Repulsion (O(N^2) - optimization possible but okay for small N)
              for (let i = 0; i < simNodes.length; i++) {
                for (let j = i + 1; j < simNodes.length; j++) {
                  let dx = simNodes[j].x - simNodes[i].x;
                  let dy = simNodes[j].y - simNodes[i].y;
                  let distSq = dx*dx + dy*dy;
                  if (distSq < 1) distSq = 1; 
                  let dist = Math.sqrt(distSq);
                  let f = k_repulse / distSq;
                  let f_x = (dx / dist) * f;
                  let f_y = (dy / dist) * f;
                  fx[i] -= f_x; fy[i] -= f_y;
                  fx[j] += f_x; fy[j] += f_y;
                }
              }

              // Spring
              const idToIndex = new Map(simNodes.map((n, i) => [n.id, i]));
              currentLinks.forEach(link => {
                const sourceIdx = idToIndex.get(link.source);
                const targetIdx = idToIndex.get(link.target);
                if (sourceIdx !== undefined && targetIdx !== undefined) {
                    const u = simNodes[sourceIdx];
                    const v = simNodes[targetIdx];
                    let dx = v.x - u.x;
                    let dy = v.y - u.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist === 0) dist = 0.01;
                    const displacement = dist - spring_len;
                    const force = displacement * k_spring;
                    const f_x = (dx / dist) * force;
                    const f_y = (dy / dist) * force;
                    fx[sourceIdx] += f_x; fy[sourceIdx] += f_y;
                    fx[targetIdx] -= f_x; fy[targetIdx] -= f_y;
                }
              });

              // Integration
              for (let i = 0; i < simNodes.length; i++) {
                const u = simNodes[i];
                if (u.id === draggedNodeIdRef.current) continue;
                fx[i] -= u.x * center_force;
                fy[i] -= u.y * center_force;
                u.vx = (u.vx + fx[i]) * 0.6; 
                u.vy = (u.vy + fy[i]) * 0.6;
                const vSq = u.vx*u.vx + u.vy*u.vy;
                if (vSq > max_velocity * max_velocity) {
                    const scale = max_velocity / Math.sqrt(vSq);
                    u.vx *= scale; u.vy *= scale;
                }
                u.x += u.vx; u.y += u.vy;
              }

              setNodes([...simNodes]);
              requestRef.current = requestAnimationFrame(tick);
            };

            requestRef.current = requestAnimationFrame(tick);
            return () => cancelAnimationFrame(requestRef.current);
          }, []);

          return (
            <div className="flex flex-col h-full w-full bg-slate-50 text-slate-900 font-sans select-none min-h-[550px]">
              {/* Header */}
              <div className="px-4 py-3 border-b border-slate-200 flex justify-between items-center bg-white shadow-sm z-10 shrink-0">
                <div>
                  <h1 className="text-lg font-bold text-slate-800">Canonical Graph Process</h1>
                  <p className="text-xs text-slate-500 font-medium max-w-md leading-tight">
                    $X_n$ is a simple graph with $n$ nodes which has $X_{n-1}$ as a sub-graph chosen with probability p.
                  </p>
                </div>
                <div className="flex items-center gap-6">
                   <div className="flex flex-col items-end">
                      <span className="text-[10px] uppercase text-slate-400 font-bold tracking-wider">Nodes</span>
                      <span className="text-xl font-mono font-bold text-indigo-600">{nodes.length}</span>
                   </div>
                   <div className="flex flex-col items-end">
                      <span className="text-[10px] uppercase text-slate-400 font-bold tracking-wider">Edges</span>
                      <span className="text-xl font-mono font-bold text-slate-600">{links.length}</span>
                   </div>
                   <div className="flex flex-col items-end">
                      <span className="text-[10px] uppercase text-slate-400 font-bold tracking-wider">Diameter</span>
                      <span className="text-xl font-mono font-bold text-emerald-500">{longestPathEdges.size}</span>
                   </div>
                </div>
              </div>

              {/* Main Canvas */}
              <div 
                className={`flex-1 relative overflow-hidden bg-slate-100 ${isPanning ? 'cursor-grabbing' : 'cursor-default'}`}
                ref={canvasRef}
                onWheel={handleWheel}
                onMouseDown={handleCanvasMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
              >
                {nodes.length < 3 && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none opacity-40">
                        <div className="text-center">
                            <Move className="mx-auto mb-2 text-slate-400" size={32} />
                            <p className="text-slate-500 font-medium">Drag Canvas to Pan â€¢ Scroll to Zoom <br/> Drag Nodes to Move</p>
                        </div>
                    </div>
                )}
                <svg width="100%" height="100%" viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}>
                  <g transform={`translate(${transform.x + dimensions.width/2}, ${transform.y + dimensions.height/2}) scale(${transform.k})`}>
                    <defs>
                      <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
                        <path d="M 100 0 L 0 0 0 100" fill="none" stroke="rgba(0,0,0,0.03)" strokeWidth="1"/>
                      </pattern>
                    </defs>
                    <rect x="-5000" y="-5000" width="10000" height="10000" fill="url(#grid)" />
                    {/* Edges */}
                    <g className="stroke-slate-400">
                      {links.map((link, i) => {
                        const sourceNode = nodes.find(n => n.id === link.source);
                        const targetNode = nodes.find(n => n.id === link.target);
                        if (!sourceNode || !targetNode) return null;
                        const edgeKey = `${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`;
                        const isDiameterEdge = longestPathEdges.has(edgeKey);
                        return (
                          <line
                            key={i} x1={sourceNode.x} y1={sourceNode.y} x2={targetNode.x} y2={targetNode.y}
                            stroke={isDiameterEdge ? "#10B981" : "currentColor"} 
                            strokeWidth={isDiameterEdge ? 4 / transform.k : 1.5 / transform.k} 
                            strokeOpacity={isDiameterEdge ? 1 : 0.4}
                          />
                        );
                      })}
                    </g>
                    {/* Nodes */}
                    {nodes.map((node) => {
                       const isNewest = node.id === nodes.length;
                       let fill = "#000000"; let stroke = "none"; let strokeWidth = 0;
                       if (isNewest && nodes.length > 1) {
                           fill = "#000000"; stroke = "rgba(255,255,255,0.5)"; strokeWidth = 3 / transform.k;
                       } else {
                           const degree = degreeMap.get(node.id) || 0;
                           let ratio = 0;
                           if (maxDegree !== minDegree) ratio = (degree - minDegree) / (maxDegree - minDegree);
                           ratio = Math.max(0, Math.min(1, ratio));
                           const hue = 270 - (ratio * 270);
                           fill = `hsl(${hue}, 75%, 55%)`; stroke = `hsl(${hue}, 75%, 40%)`; strokeWidth = 1 / transform.k;
                       }
                       let radius = 10; if (node.id === 1) radius = 12;
                       return (
                         <g key={node.id} transform={`translate(${node.x},${node.y})`} onMouseDown={(e) => handleNodeMouseDown(e, node.id)} className="cursor-grab active:cursor-grabbing">
                           <circle r={radius} fill={fill} stroke={stroke} strokeWidth={strokeWidth} className="transition-colors duration-300"/>
                           {(transform.k > 0.8 || nodes.length < 20) && (
                             <text y={radius/3} textAnchor="middle" fontSize={radius} fill="white" className="font-bold pointer-events-none no-select" style={{ textShadow: '0px 1px 2px rgba(0,0,0,0.5)' }}>
                               {node.id}
                             </text>
                           )}
                         </g>
                       );
                    })}
                  </g>
                </svg>
                {/* Zoom Controls */}
                <div className="absolute bottom-6 right-6 flex flex-col gap-2">
                    <button className="bg-white p-2 rounded shadow text-slate-600 hover:text-indigo-600" onClick={() => setTransform(t => ({...t, k: Math.min(5, t.k * 1.2)}))}>
                        <ZoomIn size={20} />
                    </button>
                    <button className="bg-white p-2 rounded shadow text-slate-600 hover:text-indigo-600" onClick={() => setTransform(t => ({...t, k: Math.max(0.1, t.k / 1.2)}))}>
                        <ZoomOut size={20} />
                    </button>
                </div>
              </div>

              {/* Histogram */}
              <Histogram 
                 degreeCounts={degreeCounts} 
                 maxDegree={maxDegree} 
                 minDegree={minDegree} 
                 dimensions={dimensions} 
                 nodesCount={nodes.length}
                 p={p}
              />

              {/* Footer Controls */}
              <div className="p-4 bg-white border-t border-slate-200 flex flex-wrap justify-center items-center gap-6 shadow-lg z-20 shrink-0">
                <div className="flex flex-col w-32">
                    <div className="flex justify-between items-center mb-1">
                        <label className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Prob (p)</label>
                        <span className="text-[10px] font-mono text-indigo-600">{p.toFixed(2)}</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value={p} onChange={handlePChange} className="h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600" />
                </div>
                <div className="h-8 w-px bg-slate-200"></div>
                <div className="flex flex-col w-32">
                    <div className="flex justify-between items-center mb-1">
                        <label className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Speed</label>
                    </div>
                    <input type="range" min="50" max="1000" step="50" value={1050 - speed} onChange={(e) => setSpeed(1050 - Number(e.target.value))} className="h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600" />
                    <div className="flex justify-between text-[8px] text-slate-400 mt-1 font-medium"><span>Slow</span><span>Fast</span></div>
                </div>
                <div className="h-8 w-px bg-slate-200"></div>
                <button onClick={() => setIsPlaying(!isPlaying)} className={`flex items-center gap-2 px-6 py-2 rounded-full font-bold transition-all shadow-md active:scale-95 ${isPlaying ? 'bg-amber-100 text-amber-700 hover:bg-amber-200' : 'bg-indigo-600 text-white hover:bg-indigo-700 hover:shadow-indigo-200'}`}>
                  {isPlaying ? <Pause size={18} /> : <Play size={18} />}
                  {isPlaying ? 'Pause' : 'Auto Play'}
                </button>
                <button onClick={addNode} disabled={isPlaying} className="flex items-center gap-2 px-4 py-2 rounded-full bg-slate-100 text-slate-700 font-medium hover:bg-slate-200 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                  <SkipForward size={18} /> Step
                </button>
                <button onClick={reset} className="p-2 text-slate-400 hover:text-slate-800 hover:bg-slate-100 rounded-full transition-colors" title="Reset Graph">
                  <RotateCcw size={20} />
                </button>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CanonicalGraphProcess />);
    </script>
</body>
</html>
